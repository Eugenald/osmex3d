<!DOCTYPE html>
<html lang="en">
    <head>
        <title>OSMEX3D Geometry builder</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <style>
            body {
                font-family: Monospace;
                background-color: #f0f0f0;
                margin: 0px;
                overflow: hidden;
            }
            .selected {
                background-color:yellow;
            }
            #topbar {
                position:absolute; 
                top:10px;               
            }
            #bottombar {
                position:absolute;
            }
            #rightbar {
                position:absolute;
            }
            #leftbar {
                position:absolute;
            }
            #right-bottombar {
                position:absolute;
            }
        </style>
    </head>
    <body>
        <div id="leftbar" style="visibility:hidden;width:300px;display:block;">
            <div class="list1" style="width:300px;border-style:solid;border-width:1px;border-color:black;float:left;">
                <select id="listOfOperations" size="12" style="width:300px;">

                </select>  
            </div>
        </div>
        <div id="topbar" style="visibility:hidden;display:inline;float:right;">
            <div id="scaling" class="group1" style="width:40px;height:40px;border-style:solid;border-width:1px;border-color:black;float:left;">
                <img src='images/scaling.png'>
            </div>
            <div id="moving" class="group1" style="width:40px;height:40px;border-style:solid;border-width:1px;border-color:black;float:left;">
                <img src='images/moving.png'>
            </div>
            <div id="rotating" class="group1" style="width:40px;height:40px;border-style:solid;border-width:1px;border-color:black;float:left;">
                <img src='images/rotating.png'>
            </div>
            <div id="noarrows" class="group1" style="width:40px;height:40px;border-style:solid;border-width:1px;border-color:black;float:left;">
                <img src='images/noarrows.png'>
            </div>
        </div>
        <div id="rightbar" style="visibility:hidden;width:40px;display:block;">
            <div id="cube" class="group2" style="width:40px;height:40px;border-style:solid;border-width:1px;border-color:black;float:left;">
                <img src='images/cube.png'>
            </div>
            <br/>
            <div id="cylinder" class="group2" style="width:40px;height:40px;border-style:solid;border-width:1px;border-color:black;float:left;">
                <img src='images/cylinder.png'>
            </div>
            <br/>
            <div id="sphere" class="group2" style="width:40px;height:40px;border-style:solid;border-width:1px;border-color:black;float:left;">
                <img src='images/sphere.png'>
            </div>
        </div>
        <div id="bottombar" style="visibility:hidden;display:inline;float:right;">            
            <div id="union" class="group3" style="width:40px;height:40px;border-style:solid;border-width:1px;border-color:black;float:left;">
                <img src='images/union.png'>
            </div>
            <div id="complement_1-2" class="group3" style="width:40px;height:40px;border-style:solid;border-width:1px;border-color:black;float:left;">
                <img src='images/complement_1-2.png'>
            </div>
            <div id="complement_2-1" class="group3" style="width:40px;height:40px;border-style:solid;border-width:1px;border-color:black;float:left;">
                <img src='images/complement_2-1.png'>
            </div>            
            <div id="intersection" class="group3" style="width:40px;height:40px;border-style:solid;border-width:1px;border-color:black;float:left;">
                <img src='images/intersection.png'>
            </div>
            <div id="rollback" class="group3" style="width:40px;height:40px;border-style:solid;border-width:1px;border-color:black;float:left;">
                <img src='images/rollback.png'>
            </div>
        </div>
        <div id="right-bottombar" style="visibility:hidden;display:inline;float:right;">
            <div id="build" class="group4" style="width:200px;height:80px;border-style:solid;border-width:1px;border-color:black;float:left;">
                <img src='images/build.png'>
            </div>
        </div>

        <script src="threejs/three.js"></script>
        <script src="threejs/ThreeCSG.js"></script>
        <script src="jquery/jquery-1.9.1.js"></script>

        <script src="scripts/SketchBuilder.js"></script>
        <script src="scripts/ObjectScene.js"></script>
        <script src="scripts/InterfaceScene.js"></script>
        <script src="scripts/GridGeometry.js"></script>
        <script src="scripts/CameraController.js"></script>
        <script src="scripts/Block.js"></script>
        <script src="scripts/Cube.js"></script>
        <script src="scripts/ScaleCube.js"></script>
        <script src="scripts/Arrow.js"></script>
        <script src="scripts/SizerArrow.js"></script>
        <script src="scripts/SizerGizmo.js"></script>
        <script src="scripts/MovingGizmo.js"></script>
        <script src="scripts/MovingArrow.js"></script>
        <script src="scripts/Torus.js"></script>
        <script src="scripts/RotationTorus.js"></script>
        <script src="scripts/RotationGizmoOverlay.js"></script>
        <script src="scripts/RotationGizmo.js"></script>

        <script type="text/javascript">

            var SCREEN_WIDTH = window.innerWidth;
            var SCREEN_HEIGHT = window.innerHeight;
            var SCREEN_FOV = 45;

            var container;

            var renderer;
            var camera = new THREE.PerspectiveCamera(SCREEN_FOV, SCREEN_WIDTH / SCREEN_HEIGHT, 1, 1000), cameraController, projector;
            var objectScene = new OSMEX.ObjectScene(), interfaceScene = new OSMEX.InterfaceScene(camera);

            var mouse = new THREE.Vector2(0, 0);

            var PICKED, SELECTED, DRAGGING, SIZING, ROTATING, SCALING, MOVING, BUILDING;
            var CLICKED = [null, null];
            var offsetVector = new THREE.Vector3();

            var groundGrid, groundPlane;

            var sizerGizmo, rotationGizmo, movingGizmo, sizerPlane, movingPlane;

            var arrowMode, objectType;

            var ROTATION_VECTOR;

            var selectedObj = [];
            var operationStack = [];

            init();
            animate();

            function init() {

                container = document.createElement('div');
                document.body.appendChild(container);

                $(document).ready(function() {
                    $("#topbar").css({
                        "left": (window.innerWidth / 2) - ($("#topbar").width() / 2) + "px",
                        "visibility": "visible"
                    });

                    $("#leftbar").css({
                        "visibility": "visible"
                    });

                    $("#bottombar").css({
                        "left": (window.innerWidth / 2) - ($("#bottombar").width() / 2) + "px",
                        "top": window.innerHeight - ($("#bottombar").height() + 10) + "px",
                        "visibility": "visible"
                    });

                    $("#rightbar").css({
                        "left": window.innerWidth - ($("#topbar").width() / 2) + "px",
                        "top": (window.innerHeight / 2) - ($("#topbar").height() / 2 * 5) + "px",
                        "visibility": "visible"
                    });

                    $("#right-bottombar").css({
                        "left": window.innerWidth - ($("#right-bottombar").width()) - ($("#topbar").width() / 4) + "px",
                        "top": (window.innerHeight) - ($("#right-bottombar").height() + 10) + "px",
                        "visibility": "visible"
                    });

                    $(".group1").click(function() {
                        $(".selected").removeClass("selected");
                        $(this).addClass("selected");
                        setArrowsType(this);
                    });
                    $(".group2").click(function() {
                        $(".selected").removeClass("selected");
                        $(this).addClass("selected");
                        addObject(this);
                    });

                    $(".group3").click(function() {
                        $(".selected").removeClass("selected");
                        $(this).addClass("selected");
                        buildNewGeometryElement(this);
                    });
                });

                renderer = new THREE.WebGLRenderer({antialias: true});

                camera = new THREE.PerspectiveCamera(SCREEN_FOV, SCREEN_WIDTH / SCREEN_HEIGHT, 1, 1000);
                camera.rotation.x -= Math.PI / 4;
                camera.position.z = 100;
                camera.position.y = 100;

                cameraController = new OSMEX.CameraController(camera);
                cameraController.userZoomSpeed = 2.0;
                cameraController.addEventListener('change', render);

                objectScene = new OSMEX.ObjectScene();
                interfaceScene = new OSMEX.InterfaceScene(camera);

                objectScene.fog = new THREE.Fog(0xffffff, 1, 1500);
                //objectScene.fog.color.setHSV(0.6, 0.05, 1);
                interfaceScene.fog = objectScene.fog;

                objectScene.add(new THREE.AmbientLight(0x3f3f3f));
                interfaceScene.add(new THREE.AmbientLight(0x3f3f3f));

                var objectLight = new THREE.DirectionalLight(0xffffff);
                objectLight.position = camera.position;
                objectScene.add(objectLight);

                var interfaceLight = new THREE.DirectionalLight(0xffffff);
                interfaceLight.position = camera.position;
                interfaceScene.add(interfaceLight);

                // GROUND
                var groundMaterial = new THREE.MeshBasicMaterial({wireframe: true, color: 0x000000});
                groundMaterial.side = THREE.DoubleSide;
                var groundGeometry = new OSMEX.GridGeometry(100, 100, 20, 20);
                groundGrid = new THREE.Mesh(groundGeometry, groundMaterial);
                objectScene.add(groundGrid);


                var blockGeometry = new THREE.CubeGeometry(1, 1, 1);
                var blockMaterial = new THREE.MeshPhongMaterial({color: 0xffffff, shading: THREE.SmoothShading});
                var cubeBlock = new OSMEX.Block(blockGeometry, blockMaterial);
                cubeBlock.scale = new THREE.Vector3(10.0, 10.0, 10.0);
                objectScene.add(cubeBlock);

                groundPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0));
                objectScene.add(groundPlane);

                sizerGizmo = new OSMEX.SizerGizmo();
                interfaceScene.add(sizerGizmo);

                rotationGizmo = new OSMEX.RotationGizmo();
                interfaceScene.add(rotationGizmo);

                movingGizmo = new OSMEX.MovingGizmo();
                interfaceScene.add(movingGizmo);

                sizerPlane = new THREE.Plane();
                movingPlane = new THREE.Plane();

                projector = new THREE.Projector();

                // RENDERER

                renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
                renderer.setClearColor(objectScene.fog.color, 1);
                renderer.autoClear = false;

                container.appendChild(renderer.domElement);

                document.addEventListener('mousemove', onDocumentMouseMove, false);
                document.addEventListener('mousedown', onDocumentMouseDown, false);
                document.addEventListener('mouseup', onDocumentMouseUp, false);
                document.addEventListener('dblclick', onDocumentDoubleClick, false);
                window.addEventListener('resize', onWindowResize, false);
            }

            function setArrowsType(element)
            {
                //alert($(element).attr('id'));
                arrowMode = $(element).attr('id');
            }
            function addObject(element)
            {
                //alert($(element).attr('id'));
                if ($(element).attr('id') != "noarrows") {
                    BUILDING = new OSMEX.SketchBuilder($(element).attr('id'));
                    BUILDING.Sketch.pickable = false;
                    BUILDING.position.set(-1000, -1000, -1000);
                    objectScene.add(BUILDING);
                }
            }

            function buildNewGeometryElement(element) {
                if ($(element).attr('id') == "rollback") {

                    if (operationStack.length > 0) {
                        var rollbackOperation = operationStack.pop();
                        objectScene.remove(rollbackOperation.output);
                        var tmp;
                        for (var i = 0; i < rollbackOperation.input.length; i++) {
                            tmp = rollbackOperation.input[i];
                            tmp.material.emissive.setHex(0x000000);
                            tmp.visible = true;
                        }
                        removeFromListOfOperations();
                    }
                } else {
                    if (!CLICKED[0] || !CLICKED[1]) {
                        alert("Error");
                    } else {

                        var first_bsp = new ThreeBSP(CLICKED[0]);
                        var second_bsp = new ThreeBSP(CLICKED[1]);

                        var nameOfOperation, result_bsp;
                        if ($(element).attr('id') == "union") {
                            nameOfOperation = "union";
                            result_bsp = first_bsp.union(second_bsp);
                        } else if ($(element).attr('id') == "intersection") {
                            nameOfOperation = "intersection";
                            result_bsp = first_bsp.intersect(second_bsp);
                        } else if ($(element).attr('id') == "complement_2-1") {
                            nameOfOperation = "complement(2-1)";
                            result_bsp = second_bsp.subtract(first_bsp);
                        } else if ($(element).attr('id') == "complement_1-2") {
                            nameOfOperation = "complement(1-2)";
                            result_bsp = first_bsp.subtract(second_bsp);
                        }

                        var material = new THREE.MeshPhongMaterial({color: 0xffffff, shading: THREE.SmoothShading});
                        var resultObj = result_bsp.toMesh(material);
                        resultObj.geometry.computeVertexNormals();

                        resultObj.scale = CLICKED[0].scale; // Bugs in scaling
                        resultObj.pickable = true;
                        resultObj.visible = true;
                        objectScene.add(resultObj);

                        CLICKED[0].visible = false;
                        CLICKED[1].visible = false;

                        var newSelected = [];
                        while (selectedObj.length > 0) {
                            newSelected.push(selectedObj.pop());
                        }
                        var newOperation = {id: operationStack.length, type: nameOfOperation, input: newSelected, output: resultObj};
                        operationStack.push(newOperation);
                        saveAtListOfOperations(newOperation.id + ": " + newOperation.type + ", input: "
                                + newOperation.input[0].id + ", " + newOperation.input[1].id + ", output: "
                                + newOperation.output.id);

                        CLICKED[0] = null;
                        CLICKED[1] = null;
                    }
                }
            }

            function saveAtListOfOperations(text) {
                var obj = document.getElementById("listOfOperations");
                obj.options[obj.options.length] = new Option(text, obj.options.length);
            }

            function removeFromListOfOperations() {
                var obj = document.getElementById("listOfOperations");
                obj.length = obj.length - 1;
            }

            function onWindowResize() {

                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();

                renderer.setSize(window.innerWidth, window.innerHeight);
            }

            function getPickedObject() {

                function getFirstSuitableObject(raycaster, objects, recursive) {

                    var intersects = raycaster.intersectObjects(objects, recursive);


                    if (intersects.length > 0) {

                        for (i = 0; i < intersects.length; i++) {

                            var intersector = intersects[i];
                            if (intersector.object.parent.name === "RotationGizmoOverlay")
                                return null;

                            if (intersector.object.pickable && intersector.object.visible) {
                                return intersector.object;
                            }
                        }
                    }

                    return null;
                }

                var vector = new THREE.Vector3(mouse.x, mouse.y, 1);
                projector.unprojectVector(vector, camera);

                var raycaster = new THREE.Raycaster(camera.position, vector.sub(camera.position).normalize());

                var pickedObject = getFirstSuitableObject(raycaster, interfaceScene.children, true);

                if (pickedObject === null) {

                    pickedObject = getFirstSuitableObject(raycaster, objectScene.children);
                }

                return pickedObject;
            }

            function onDocumentDoubleClick(event) {
                event.preventDefault();

                if (event.button == 0) {

                    var pickedObject = getPickedObject();

                    if (!CLICKED[0] && !CLICKED[1]) {
                        pickedObject.material.emissive.setHex(0x00ff00);
                        CLICKED[0] = pickedObject;
                        selectedObj.push(pickedObject);
                    } else if (CLICKED[0] == pickedObject) {
                        CLICKED[0] = null;
                        pickedObject.material.emissive.setHex(0x000000);
                        selectedObj.shift();
                    } else if (!CLICKED[1]) {
                        pickedObject.material.emissive.setHex(0x0000ff);
                        CLICKED[1] = pickedObject;
                        selectedObj.push(pickedObject);
                    } else if (CLICKED[1] == pickedObject) {
                        CLICKED[1] = null;
                        pickedObject.material.emissive.setHex(0x000000);
                        pickedObject.pop();
                    } else if (CLICKED[0] && CLICKED[1]) {
                    } else {
                        pickedObject.material.emissive.setHex(0x00ff00);
                        CLICKED[0] = pickedObject;
                        selectedObj.unshift(pickedObject);
                    }

                }
            }

            function onDocumentMouseMove(event) {

                event.preventDefault();

                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

                if (BUILDING) {

                    var vector = new THREE.Vector3(mouse.x, mouse.y, 0.5);
                    projector.unprojectVector(vector, camera);
                    var ray = new THREE.Ray(camera.position, vector.sub(camera.position).normalize());
                    var intersectPoint = ray.intersectPlane(groundPlane);

                    if (intersectPoint !== undefined) {

                        BUILDING.position.copy(intersectPoint);
                    }
                }

                if (DRAGGING) {

                    var vector = new THREE.Vector3(mouse.x, mouse.y, 0.5);
                    projector.unprojectVector(vector, camera);
                    var raycaster = new THREE.Raycaster(camera.position, vector.sub(camera.position).normalize());
                    var intersects = raycaster.intersectObject(groundGrid);

                    if (intersects.length > 0) {

                        DRAGGING.position.copy(intersects[0].point.sub(offsetVector));
                    }
                }
                else if (SIZING) {

                    var vector = new THREE.Vector3(mouse.x, mouse.y, 0.5);
                    projector.unprojectVector(vector, camera);
                    var ray = new THREE.Ray(camera.position, vector.sub(camera.position).normalize());
                    var intersectPoint = ray.intersectPlane(sizerPlane);

                    if (intersectPoint !== undefined) {

                        intersectPoint.sub(SIZING.matrixWorld.getPosition());
                        intersectPoint.multiplyScalar(1.0 / SIZING.parent.scale.x); // to compensate changing scale on changing distance
                        var len = SIZING.dir.dot(intersectPoint);
                        // TODO: workaround should be reimplemented
                        if (Math.abs(SIZING.len - len) < (SIZING.maxLength - SIZING.minLength)) {

                            // console.log ("length=",len);
                            SIZING.setLength(len);

                        }
                    }
                }
                else if (MOVING) {

                    var vector = new THREE.Vector3(mouse.x, mouse.y, 1);
                    projector.unprojectVector(vector, camera);
                    var ray = new THREE.Ray(camera.position, vector.sub(camera.position).normalize());
                    var intersectPoint = ray.intersectPlane(movingPlane);

                    if (intersectPoint !== undefined) {

                        var position = intersectPoint.sub(movingPlane.normal);
                        MOVING.setPosition(position);
                    }
                }
                else if (SCALING) {
                    var mouseX = (mouse.x * SCREEN_WIDTH / 2) / 10;

                    var sizingPos = projector.projectVector(SCALING.matrixWorld.getPosition().clone(), camera);
                    sizingPos.x = (sizingPos.x * SCREEN_WIDTH / 2) / 10;
                    var len = mouseX - sizingPos.x;

                    SCALING.setScale(len);
                }
                else if (ROTATING) {

                    var mouseX = (mouse.x * SCREEN_WIDTH / 2) + SCREEN_WIDTH / 2;
                    var mouseY = -(mouse.y * SCREEN_HEIGHT / 2) + SCREEN_HEIGHT / 2;
                    var vector = projector.projectVector(ROTATING.matrixWorld.getPosition().clone(), camera);

                    vector.x = (vector.x * SCREEN_WIDTH / 2) + SCREEN_WIDTH / 2;
                    vector.y = -(vector.y * SCREEN_HEIGHT / 2) + SCREEN_HEIGHT / 2;
                    var currentVector = new THREE.Vector2(-(vector.x - mouseX), vector.y - mouseY).normalize();

                    ROTATING.setAngle(ROTATION_VECTOR, currentVector);

                }
                else {

                    var pickedObject = getPickedObject();
                    if (!CLICKED[1] || !CLICKED[0]) {
                        if (PICKED != pickedObject) {
                            if (PICKED) {
                                if (CLICKED[0] != PICKED && CLICKED[1] != PICKED) {
                                    PICKED.material.emissive.setHex(PICKED.oldEmissive);
                                }
                            }

                            PICKED = pickedObject;

                            if (PICKED) {
                                if (CLICKED[0] != PICKED || CLICKED[1] != PICKED) {
                                    if (CLICKED[0] != PICKED && CLICKED[1] != PICKED) {
                                        PICKED.oldEmissive = PICKED.material.emissive.getHex();
                                        PICKED.material.emissive.setHex(0xff0000);
                                    } else {
                                        PICKED.oldEmissive = 0x000000;
                                    }

                                }
                            }
                        }
                    }
                }
            }

            function onDocumentMouseDown(event) {

                event.preventDefault();

                if (event.button == 0) {

                    if (BUILDING) {

                        var vector = new THREE.Vector3(mouse.x, mouse.y, 1);
                        projector.unprojectVector(vector, camera);
                        var raycaster = new THREE.Raycaster(camera.position, vector.sub(camera.position).normalize());
                        var intersects = raycaster.intersectObject(groundGrid);

                        if (intersects.length > 0) {

                            var object = new OSMEX.SketchBuilder(BUILDING.name);
                            object.Sketch.position.copy(intersects[0].point);
                            object.Sketch.material.color.setHex(0xffffff);
                            objectScene.add(object.Sketch);

                        }

                        objectScene.remove(BUILDING);

                    }

                    if (PICKED) {

                        var pickRef = (PICKED.pickRef !== undefined ? PICKED.pickRef : PICKED);

                        if (pickRef instanceof OSMEX.Block) {

                            SELECTED = pickRef;
                            DRAGGING = pickRef;


                            var vector = new THREE.Vector3(mouse.x, mouse.y, 0.5);
                            projector.unprojectVector(vector, camera);
                            var ray = new THREE.Ray(camera.position, vector.sub(camera.position).normalize());
                            var intersectPoint = ray.intersectPlane(groundPlane);
                            offsetVector.copy(intersectPoint).sub(DRAGGING.position);
                        }
                        else if (pickRef instanceof OSMEX.SizerArrow) {

                            SIZING = pickRef;
                            console.log("SIZING before", SIZING.dir);
                            SELECTED.matrix.rotateAxis(SIZING.dir);
                            console.log("SIZING after", SIZING.dir);
                            var sizingPos = SIZING.matrixWorld.getPosition();
                            var cameraDir = camera.position.clone().sub(sizingPos).normalize();
                            var rightDir = cameraDir.clone().cross(SIZING.dir);
                            var forwardDir = SIZING.dir.clone().cross(rightDir);

                            sizerPlane.setFromNormalAndCoplanarPoint(forwardDir, sizingPos);
                            //SELECTED.matrix.rotateAxis(sizerPlane.normal);
                            // TODO: situation when user is doing camera rotation while LMK pressed should be considered!
                        }
                        else if (pickRef instanceof OSMEX.MovingArrow) {

                            MOVING = pickRef;
                            var sizingPos = MOVING.matrixWorld.getPosition();
                            var cameraDir = camera.position.clone().sub(sizingPos).normalize();
                            var rightDir = cameraDir.clone().cross(MOVING.dir);
                            var forwardDir = MOVING.dir.clone().cross(rightDir);
                            movingPlane.setFromNormalAndCoplanarPoint(forwardDir, sizingPos);


                        }
                        else if (pickRef instanceof OSMEX.ScaleCube) {

                            SCALING = pickRef;

                        }
                        else if (pickRef instanceof OSMEX.RotationTorus) {
                            ROTATING = pickRef;

                            var mouseX = (mouse.x * SCREEN_WIDTH / 2) + SCREEN_WIDTH / 2;
                            var mouseY = -(mouse.y * SCREEN_HEIGHT / 2) + SCREEN_HEIGHT / 2;
                            var vector = projector.projectVector(ROTATING.matrixWorld.getPosition().clone(), camera);

                            vector.x = (vector.x * SCREEN_WIDTH / 2) + SCREEN_WIDTH / 2;
                            vector.y = -(vector.y * SCREEN_HEIGHT / 2) + SCREEN_HEIGHT / 2;
                            ROTATION_VECTOR = new THREE.Vector2(-(vector.x - mouseX), vector.y - mouseY).normalize();

                        }
                        else {

                            SELECTED = null;
                        }
                    }
                    else {

                        SELECTED = null;
                    }
                    if (arrowMode == "scaling")
                        sizerGizmo.setTarget(SELECTED)
                    else if (arrowMode == "moving")
                        movingGizmo.setTarget(SELECTED);
                    else if (arrowMode == "rotating")
                        rotationGizmo.setTarget(SELECTED);
                    ;

                }
            }

            function onDocumentMouseUp(event) {

                event.preventDefault();

                if (event.button == 0) {

                    if (SIZING)
                        SIZING.restoreDefaultLength();
                    if (SCALING)
                        SCALING.restoreDefaultScale();

                    BUILDING = null;
                    DRAGGING = null;
                    SIZING = null;
                    SCALING = null;
                    ROTATING = null;
                    MOVING = null;
                    ROTATION_VECTOR = null;
                }
            }

            function animate() {

                requestAnimationFrame(animate);

                update();
                render();
            }

            function update() {

                cameraController.update();
                rotationGizmo.update(camera);
                sizerGizmo.update();
                movingGizmo.update();
            }

            function render() {

                renderer.clear();
                renderer.render(objectScene, camera);

                renderer.clear(false, true, false); // clear only Depth
                renderer.render(interfaceScene, camera);
            }

        </script>

    </body>
</html>