<!DOCTYPE html>
<html lang="en">
    <head>
        <title>OSMEX3D Object editor</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

        <style>
            body {
                font-family: Monospace;
                background-color: #f0f0f0;
                margin: 0px;
                overflow: hidden;
            }
            .selected {
                background-color:yellow;
            }
            #topbar {
                position:absolute; 
                top:10px;               
            }
            #rightbar {
                position:absolute;
            }
        </style>
    </head>
    <body>
        
	<div id="topbar" style="visibility:hidden;display:inline;float:right;">
		<div id="scaling" class="group1" style="width:40px;height:40px;border-style:solid;border-width:1px;border-color:black;float:left;">
			<img src='images/scaling.png'>
		</div>
		<div id="moving" class="group1" style="width:40px;height:40px;border-style:solid;border-width:1px;border-color:black;float:left;">
			<img src='images/moving.png'>
		</div>
		<div id="rotating" class="group1" style="width:40px;height:40px;border-style:solid;border-width:1px;border-color:black;float:left;">
			<img src='images/rotating.png'>
		</div>
		<div id="noarrows" class="group1" style="width:40px;height:40px;border-style:solid;border-width:1px;border-color:black;float:left;">
			<img src='images/noarrows.png'>
		</div>

	</div>
	<div id="rightbar" style="visibility:hidden;width:40px;display:block;">
		<div id="cube" class="group2" style="width:40px;height:40px;border-style:solid;border-width:1px;border-color:black;float:left;">
			<img src='images/cube.png'>
		</div>
		<br/>
		<div id="cylinder" class="group2" style="width:40px;height:40px;border-style:solid;border-width:1px;border-color:black;float:left;">
			<img src='images/cylinder.png'>
		</div>
		<br/>
		<div id="sphere" class="group2" style="width:40px;height:40px;border-style:solid;border-width:1px;border-color:black;float:left;">
			<img src='images/sphere.png'>
		</div>

	</div>

        <script src="threejs/three.js"></script>
        <script src="jquery/jquery-1.9.1.js"></script>

        <script src="scripts/SketchBuilder.js"></script>
        <script src="scripts/ObjectScene.js"></script>
        <script src="scripts/InterfaceScene.js"></script>
        <script src="scripts/GridGeometry.js"></script>
        <script src="scripts/CameraController.js"></script>
        <script src="scripts/Block.js"></script>
        <script src="scripts/Cube.js"></script>
        <script src="scripts/ScaleCube.js"></script>
        <script src="scripts/Arrow.js"></script>
        <script src="scripts/SizerArrow.js"></script>
        <script src="scripts/SizerGizmo.js"></script>
        <script src="scripts/MovingGizmo.js"></script>
        <script src="scripts/MovingArrow.js"></script>
        <script src="scripts/Torus.js"></script>
        <script src="scripts/RotationTorus.js"></script>
        <script src="scripts/RotationGizmoOverlay.js"></script>
        <script src="scripts/RotationGizmo.js"></script>

        <script type="text/javascript">
            
            var SCREEN_WIDTH = window.innerWidth;
            var SCREEN_HEIGHT = window.innerHeight;
            var SCREEN_FOV = 45;

            var container;

            var renderer;
            var camera = new THREE.PerspectiveCamera( SCREEN_FOV, SCREEN_WIDTH / SCREEN_HEIGHT, 1, 1000 ), cameraController, projector;
            var objectScene = new OSMEX.ObjectScene(), interfaceScene = new OSMEX.InterfaceScene(camera);

            var mouse = new THREE.Vector2(0, 0);
			
            var PICKED, SELECTED, DRAGGING, SIZING, ROTATING, SCALING, MOVING, BUILDING;
            var offsetVector = new THREE.Vector3();
            
            var groundGrid, groundPlane;
			
            var sizerGizmo, rotationGizmo, movingGizmo, actionPlane;
            
            var arrowMode, objectType;
            
            init();
            animate();

            function init() {
                
                container = document.createElement( 'div' );
                document.body.appendChild( container );                
                
		$(document).ready(function(){
                    $("#topbar").css({
                        "left":(window.innerWidth/2)-($("#topbar").width()/2)+"px",
                        "visibility":"visible"
                    });
                    
                    $("#rightbar").css({
                        "left":window.innerWidth-($("#topbar").width()/2)+"px",
                        "top":(window.innerHeight/2)-($("#topbar").height()/2*5)+"px",
                        "visibility":"visible"
                    });
                    
                    $("#rightbar").show();
			$(".group1").click(function(){
				$(".selected").removeClass("selected");
				$(this).addClass("selected");
				setArrowsType(this);
			});
			$(".group2").click(function(){
				$(".selected").removeClass("selected");
				$(this).addClass("selected");
				addObject(this);
			});
		});                
                     
               
                  
                
                renderer = new THREE.WebGLRenderer( { antialias: true } );

                camera = new THREE.PerspectiveCamera( SCREEN_FOV, SCREEN_WIDTH / SCREEN_HEIGHT, 1, 1000 );
                camera.rotation.x -= Math.PI / 4;
                camera.position.z = 100;
                camera.position.y = 100;
				
                cameraController = new OSMEX.CameraController( camera );
                cameraController.userZoomSpeed = 2.0;
                cameraController.addEventListener( 'change', render );
				
               objectScene = new OSMEX.ObjectScene();
               interfaceScene = new OSMEX.InterfaceScene(camera);

                objectScene.fog = new THREE.Fog( 0xffffff, 1, 1500 );
                objectScene.fog.color.setHSV( 0.6, 0.05, 1 );
                interfaceScene.fog = objectScene.fog;

                objectScene.add( new THREE.AmbientLight( 0x3f3f3f ) );
                interfaceScene.add( new THREE.AmbientLight( 0x3f3f3f ) );
				
                var objectLight = new THREE.DirectionalLight( 0xffffff);
                objectLight.position = camera.position;
                objectScene.add( objectLight );
				
                var interfaceLight = new THREE.DirectionalLight( 0xffffff);
                interfaceLight.position = camera.position;
                interfaceScene.add( interfaceLight );
				
                // GROUND
                var groundMaterial = new THREE.MeshBasicMaterial( { wireframe: true, color: 0x000000 } );
                groundMaterial.side = THREE.DoubleSide;
                var groundGeometry = new OSMEX.GridGeometry( 100, 100, 20, 20 );
                groundGrid = new THREE.Mesh( groundGeometry, groundMaterial );
                objectScene.add( groundGrid );           
                
                
                var blockGeometry = new THREE.CubeGeometry( 1, 1, 1 );
                var blockMaterial = new THREE.MeshPhongMaterial( { color: 0xffffff, shading: THREE.SmoothShading } );//new THREE.MeshBasicMaterial( { color: 0xffffff } );//vertexColors: THREE.FaceColors } );
                var cubeBlock = new OSMEX.Block( blockGeometry, blockMaterial );
                cubeBlock.scale = new THREE.Vector3(10.0, 10.0, 10.0);
                objectScene.add( cubeBlock );
                
                
                groundPlane = new THREE.Plane( new THREE.Vector3(0, 1, 0));
                objectScene.add (groundPlane);
                
				
                sizerGizmo = new OSMEX.SizerGizmo();
                interfaceScene.add(sizerGizmo);
                
                rotationGizmo = new OSMEX.RotationGizmo();
                interfaceScene.add(rotationGizmo);
                
                movingGizmo = new OSMEX.MovingGizmo();
                interfaceScene.add(movingGizmo);
                
   
                actionPlane = new THREE.Plane();
						
                projector = new THREE.Projector();	

                // RENDERER

                renderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );
                renderer.setClearColor( objectScene.fog.color, 1 );
                renderer.autoClear = false;

                container.appendChild( renderer.domElement );
				
                document.addEventListener( 'mousemove', onDocumentMouseMove, false );
                document.addEventListener( 'mousedown', onDocumentMouseDown, false );
                document.addEventListener( 'mouseup', onDocumentMouseUp, false );
                window.addEventListener( 'resize', onWindowResize, false );
            }
            
          function setArrowsType(element)
		{
                    //alert($(element).attr('id'));
                     arrowMode = $(element).attr('id');
		}
            function addObject(element)
		{
                    //alert($(element).attr('id'));
                    if($(element).attr('id') != "noarrows"){
                    BUILDING = new OSMEX.SketchBuilder($(element).attr('id'));
                    BUILDING.Sketch.pickable = false;
                    BUILDING.position.set(-1000,-1000,-1000);
                    objectScene.add (BUILDING);                    
                    }                       
		}
			
            function onWindowResize() {

                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();

                renderer.setSize( window.innerWidth, window.innerHeight );
            }
            
            function getPickedObject() {
                
                function getFirstSuitableObject(raycaster, objects, recursive) {
                    
                    var intersects = raycaster.intersectObjects( objects, recursive );
                    

                    if ( intersects.length > 0 ) {

                        for( i = 0; i < intersects.length; i++ ) {
                            
                            var intersector = intersects[i];
                            if (intersector.object.parent.name === "RotationGizmoOverlay") return null;

                            if ( intersector.object.pickable && intersector.object.visible ) {
                                return intersector.object;
                            }
                        }
                    }

                    return null;
                } 
                
                var vector = new THREE.Vector3( mouse.x, mouse.y, 1 );
                projector.unprojectVector( vector, camera );
				
                var raycaster = new THREE.Raycaster( camera.position, vector.subSelf( camera.position ).normalize() );
                
                var pickedObject = getFirstSuitableObject(raycaster, interfaceScene.children, true);
                
                if (pickedObject === null) {
                    
                    pickedObject = getFirstSuitableObject(raycaster, objectScene.children);
                }
                
                return pickedObject;
            }

            function onDocumentMouseMove( event ) {
                
                event.preventDefault();

                mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
                mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
                
                if ( BUILDING ) {       
                 
                    var vector = new THREE.Vector3( mouse.x, mouse.y, 0.5 );
	            projector.unprojectVector( vector, camera );
                    var ray = new THREE.Ray( camera.position, vector.subSelf( camera.position ).normalize() );
                    var intersectPoint = ray.intersectPlane(groundPlane);
                 
                    if ( intersectPoint !== undefined ) {
    
                        BUILDING.position.copy(intersectPoint);                    
                    }               
                }
                
                if ( DRAGGING ) {
                    
                    var vector = new THREE.Vector3( mouse.x, mouse.y, 0.5 );
	            projector.unprojectVector( vector, camera );
                    var raycaster = new THREE.Raycaster( camera.position, vector.subSelf( camera.position ).normalize() );
                    var intersects = raycaster.intersectObject(groundGrid);
                 
                    if ( intersects.length > 0 ) {
                        
                        DRAGGING.position.copy(intersects[0].point.subSelf( offsetVector ));
                    }
                }
                else if ( SIZING ) {
                    
                    var vector = new THREE.Vector3( mouse.x, mouse.y, 0.5 );
                    projector.unprojectVector( vector, camera );
                    var ray = new THREE.Ray( camera.position, vector.subSelf( camera.position ).normalize() );
                    var intersectPoint = ray.intersectPlane(actionPlane);

                    if (intersectPoint !== undefined) {
                        
                        intersectPoint.subSelf(SIZING.matrixWorld.getPosition());
                        intersectPoint.multiplyScalar(1.0 / SIZING.parent.scale.x); // to compensate changing scale on changing distance
                        var len = SIZING.dir.dot(intersectPoint);
                        // TODO: workaround should be reimplemented
                        if (Math.abs(SIZING.len - len) < (SIZING.maxLength - SIZING.minLength)) {
                            
                           // console.log ("length=",len);
                            SIZING.setLength(len);
                            
                        }
                    }
                }
                else if ( MOVING ) {
                    
                    var vector = new THREE.Vector3( mouse.x, mouse.y, 1 );
	            projector.unprojectVector( vector, camera );
                    var ray = new THREE.Ray( camera.position, vector.subSelf( camera.position ).normalize() );
                    var intersectPoint = ray.intersectPlane(movingPlane);
                 
                    if ( intersectPoint !== undefined ) {
                        
                        var position = intersectPoint.subSelf( movingPlane.normal );
                        MOVING.setPosition (position);
                    }
                }
                else if ( SCALING ) {
                    
                    var mouseX = (mouse.x* SCREEN_WIDTH/2)/10;
                        
                    var sizingPos = projector.projectVector( SCALING.matrixWorld.getPosition().clone(), camera );
                    sizingPos.x = (sizingPos.x * SCREEN_WIDTH/2)/10;
                    var len = mouseX - sizingPos.x;

                    SCALING.setScale(len);     
                }
                else if ( ROTATING ) {
                    
                    var vector = new THREE.Vector3( mouse.x, mouse.y, 0.5 );
                    projector.unprojectVector( vector, camera );
                    var ray = new THREE.Ray( camera.position, vector.subSelf( camera.position ).normalize() );
                    var intersectPoint = ray.intersectPlane(actionPlane);

                    if (intersectPoint === undefined) {
                        alert("RotationEnd plane intersection problem!");
                    }

                    intersectPoint.subSelf(ROTATING.matrixWorld.getPosition());

                    ROTATING.finishRotation(intersectPoint.clone().normalize());   
                }
                else {
                    
                    var pickedObject = getPickedObject();

                    if ( PICKED != pickedObject ) {

                        if ( PICKED ) {
                            PICKED.material.emissive.setHex( PICKED.oldEmissive );
                        }

                        PICKED = pickedObject;

                        if ( PICKED ) {
                            
                            PICKED.oldEmissive = PICKED.material.emissive.getHex();
                            PICKED.material.emissive.setHex( 0xff0000 );
                        }
                    }
                }
            }
			
            function onDocumentMouseDown( event ) {
                
                event.preventDefault();
				
                if (event.button == 0) {
                    
                    if (BUILDING){

                    var vector = new THREE.Vector3( mouse.x, mouse.y, 1 );
	            projector.unprojectVector( vector, camera );
                    var raycaster = new THREE.Raycaster( camera.position, vector.subSelf( camera.position ).normalize() );
                    var intersects = raycaster.intersectObject(groundGrid);
                 
                    if ( intersects.length > 0 ) {
                        
                        var object = new OSMEX.SketchBuilder(BUILDING.name);
                        object.Sketch.position.copy(intersects[0].point);
                        object.Sketch.material.color.setHex(0xffffff);                        
                        objectScene.add (object.Sketch);
                        
                        }
                        
                    objectScene.remove (BUILDING);
                    
                    }
                                     
                    if ( PICKED ) {
                        
                        var pickRef = (PICKED.pickRef !== undefined ? PICKED.pickRef : PICKED);
                        
                        if ( pickRef instanceof OSMEX.Block ) {

                            SELECTED = pickRef;
                            DRAGGING = pickRef;


                            var vector = new THREE.Vector3( mouse.x, mouse.y, 0.5 );
                            projector.unprojectVector( vector, camera );
                            var ray = new THREE.Ray( camera.position, vector.subSelf( camera.position ).normalize() );
                            var intersectPoint = ray.intersectPlane(groundPlane);                         
                            offsetVector.copy( intersectPoint ).subSelf( DRAGGING.position );
                        }
                        else if ( pickRef instanceof OSMEX.SizerArrow ) {
                            
                            SIZING = pickRef;
                            console.log("SIZING before",SIZING.dir);
                            SELECTED.matrix.rotateAxis(SIZING.dir);
                            console.log("SIZING after",SIZING.dir);
                            var sizingPos = SIZING.matrixWorld.getPosition();
                            var cameraDir = camera.position.clone().subSelf(sizingPos).normalize();
                            var rightDir = cameraDir.clone().crossSelf(SIZING.dir);
                            var forwardDir = SIZING.dir.clone().crossSelf(rightDir);
                            actionPlane.setFromNormalAndCoplanarPoint(forwardDir, sizingPos);
                            // TODO: situation when user is doing camera rotation while LMK pressed should be considered!
                        }
                        else if ( pickRef instanceof OSMEX.MovingArrow ) {
                            
                            MOVING = pickRef;
                            var sizingPos = MOVING.matrixWorld.getPosition();
                            var cameraDir = camera.position.clone().subSelf(sizingPos).normalize();
                            var rightDir = cameraDir.clone().crossSelf(MOVING.dir);  
                            var forwardDir = MOVING.dir.clone().crossSelf(rightDir);
                            movingPlane.setFromNormalAndCoplanarPoint(forwardDir, sizingPos);
                            
                            
                        }
                        else if ( pickRef instanceof OSMEX.ScaleCube ) {
                            
                            SCALING = pickRef;
                                                       
                        }
                        else if ( pickRef instanceof OSMEX.RotationTorus ) {
                            
                            ROTATING = pickRef;
                            
                            ROTATING.matrixRotationWorld.extractRotation( ROTATING.matrixWorld );
                            var normal = ROTATING.matrixRotationWorld.multiplyVector3( ROTATING.dir.clone() ).normalize();
                            
                            var rotationPos = ROTATING.matrixWorld.getPosition();
                            actionPlane.setFromNormalAndCoplanarPoint(normal, rotationPos);
                            // TODO: situation when user is doing camera rotation while LMK pressed should be considered!
                            
                            var vector = new THREE.Vector3( mouse.x, mouse.y, 0.5 );
                            projector.unprojectVector( vector, camera );
                            var ray = new THREE.Ray( camera.position, vector.subSelf( camera.position ).normalize() );
                            var intersectPoint = ray.intersectPlane(actionPlane);

                            if (intersectPoint === undefined) {
                                alert("RotationStart plane intersection problem!");
                            }
                            
                            intersectPoint.subSelf(ROTATING.matrixWorld.getPosition());

                            ROTATING.setStartRotationVector(intersectPoint.clone().normalize());
                           
                        }
                        else {
                            
                            SELECTED = null;
                        }
                    }
                    else {
                        
                        SELECTED = null;
                    }
                    if(arrowMode == "scaling") sizerGizmo.setTarget(SELECTED)
                        else if(arrowMode == "moving") movingGizmo.setTarget(SELECTED);
                            else if(arrowMode == "rotating") rotationGizmo.setTarget(SELECTED);;
                    
                }

            }
            
            function onDocumentMouseUp( event ) {
                
                event.preventDefault();
				
                if (event.button == 0) {
                    
                    if (SIZING) SIZING.restoreDefaultLength();
                    if (SCALING) SCALING.restoreDefaultScale();
                    
                    BUILDING = null;
                    DRAGGING = null;
                    SIZING = null;
                    SCALING = null;
                    ROTATING = null;
                    MOVING = null;
                }
            }

            function animate() {
                
                requestAnimationFrame( animate );
                
                update();
                render();
            }
            
            function update() {
                
                cameraController.update();
                rotationGizmo.update(camera);
                sizerGizmo.update();
                movingGizmo.update();
            } 
			
            function render() {
                
                renderer.clear();
                renderer.render( objectScene, camera );
                
                renderer.clear(false, true, false); // clear only Depth
                renderer.render( interfaceScene, camera );
            }

        </script>

    </body>
</html>
