<!DOCTYPE html>
<html lang="en">
    <head>
        <title>OSMEX3D Object editor</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

        <style>
            body {
                font-family: Monospace;
                background-color: #f0f0f0;
                margin: 0px;
                overflow: hidden;
            }
            .selected {
                background-color:yellow;
            }
            #topbar {
                position:absolute; 
                top:10px;               
            }
            #rightbar {
                position:absolute;
            }
            
            #righttopbar {
                position:absolute; 
            }   
        </style>
    </head>
    <body>
        
	<div id="topbar" style="visibility:hidden;display:inline;float:right;">
		<div id="moving" class="group1" style="width:40px;height:40px;border-style:solid;border-width:1px;border-color:black;float:left;">
			<img src='images/scaling.png'>
		</div>
		<div id="scaling" class="group1" style="width:40px;height:40px;border-style:solid;border-width:1px;border-color:black;float:left;">
			<img src='images/moving.png'>
		</div>
		<div id="rotating" class="group1" style="width:40px;height:40px;border-style:solid;border-width:1px;border-color:black;float:left;">
			<img src='images/rotating.png'>
		</div>
		<div id="delete" class="group1" style="width:40px;height:40px;border-style:solid;border-width:1px;border-color:black;float:left;">
			<img src='images/noarrows.png'>
		</div>
            	<div id="build_box" class="group1" style="width:40px;height:40px;border-style:solid;border-width:0px;border-color:black;float:left;">
			<img src='images/build_box.png'>
		</div>

	</div>
        
        <div id="righttopbar" style="visibility:hidden;width:200px;display:block;text-align:rigth;">
            <input type="radio" checked="checked" id="PerspCam" name="Camera" value="Perspective">PerspectiveCamera
            <br>
            <input type="radio" id="OrthCam" name="Camera" value="Orthographic">OrthographicCamera
            <br>
            <input type="checkbox" id="BBox" onchange="addBoundingBox();"> Bounding Box<br>
        </div>
        
	<div id="rightbar" style="visibility:hidden;width:40px;display:block;">
		<div id="cube" class="group2" style="width:40px;height:40px;border-style:solid;border-width:1px;border-color:black;float:left;">
			<img src='images/cube.png'>
		</div>
		<br/>
		<div id="cylinder" class="group2" style="width:40px;height:40px;border-style:solid;border-width:1px;border-color:black;float:left;">
			<img src='images/cylinder.png'>
		</div>
		<br/>
		<div id="sphere" class="group2" style="width:40px;height:40px;border-style:solid;border-width:1px;border-color:black;float:left;">
			<img src='images/sphere.png'>
		</div>

	</div>

        <script src="threejs/three.js"></script>
        <script src="jquery/jquery-1.9.1.js"></script>

        <script src="scripts/SketchBuilder.js"></script>
        <script src="scripts/BoundingBox.js"></script>
        <script src="scripts/ObjectScene.js"></script>
        <script src="scripts/InterfaceScene.js"></script>
        <script src="scripts/Grid.js"></script>
        <script src="scripts/Camera.js"></script>
        <script src="scripts/CameraController.js"></script>
        <script src="scripts/Block.js"></script>
        <script src="scripts/Cube.js"></script>
        <script src="scripts/ScaleCube.js"></script>
        <script src="scripts/Arrow.js"></script>
        <script src="scripts/SizerArrow.js"></script>
        <script src="scripts/SizerGizmo.js"></script>
        <script src="scripts/MovingGizmo.js"></script>
        <script src="scripts/MovingGizmoPlane.js"></script>
        <script src="scripts/MovingArrow.js"></script>
        <script src="scripts/Torus.js"></script>
        <script src="scripts/RotationTorus.js"></script>
        <script src="scripts/RotationGizmoOverlay.js"></script>
        <script src="scripts/RotationGizmo.js"></script>
        <script src="scripts/BoxBuilder.js"></script>

        <script type="text/javascript">
            
            var SCREEN_WIDTH = window.innerWidth;
            var SCREEN_HEIGHT = window.innerHeight;
            var SCREEN_FOV = 45;
            var FIRST_PICKABLE_OBJ = 5;

            var container;

            var renderer;
            var camera;
            var cameraController, projector;
            var objectScene, interfaceScene;

            var mouse = new THREE.Vector2(0, 0);
			
            var PICKED, SELECTED, DRAGGING, SIZING, ROTATING, SCALING, MOVING, BUILDING;
            var offsetVector = new THREE.Vector3();
            
            var groundGrid, groundPlane;
			
            var sizerGizmo, rotationGizmo, movingGizmo, actionPlane;
            
            var arrowMode, objectType;
            
            init();
            animate();

            function init() {
                
                container = document.createElement( 'div' );
                document.body.appendChild( container );                
                
		$(document).ready(function(){
                    $("#topbar").css({
                        "left":(window.innerWidth/2)-($("#topbar").width()/2)+"px",
                        "visibility":"visible"
                    });
                    
                    $("#rightbar").css({
                        "left":window.innerWidth-($("#topbar").width()/2)+"px",
                        "top":(window.innerHeight/2)-($("#topbar").height()/2*5)+"px",
                        "visibility":"visible"
                    });
                    
                    $("#righttopbar").css({
                        "left":(window.innerWidth)-($("#topbar").width())+"px",
                        "top":($("#topbar").height()/2)+"px",
                        "visibility":"visible"
                    });
                    
			$(".group1").click(function(){
				$(".selected").removeClass("selected");
				$(this).addClass("selected");
				setArrowsType(this);
			});
			$(".group2").click(function(){
				$(".selected").removeClass("selected");
				$(this).addClass("selected");
				addObject(this);
			});
                        $('input:radio').change(function(){
                                if($('input[name="Camera"]:checked').val() == "Orthographic")
                                    camera.toOrthographic();
                                else camera.toPerspective()
                        }
                        );
		});                
                     
                renderer = new THREE.WebGLRenderer( { antialias: true } );
                
                camera = new OSMEX.Camera( SCREEN_WIDTH, SCREEN_HEIGHT, SCREEN_FOV, 1, 300, 1, 300 );
                camera.rotation.x -= Math.PI / 4;
                camera.position.z = 100;
                camera.position.y = 100;
				
                cameraController = new OSMEX.CameraController( camera );
                cameraController.ZoomSpeed = 2.0;
                cameraController.addEventListener( 'change', onCameraChange );
				
                objectScene = new OSMEX.ObjectScene();
                interfaceScene = new OSMEX.InterfaceScene(camera);

                objectScene.fog = new THREE.Fog( 0xFBFBFB, 1, 1500 );

                objectScene.add( new THREE.AmbientLight( 0x3f3f3f ) );
                interfaceScene.add( new THREE.AmbientLight( 0x3f3f3f ) );
				
                var objectLight = new THREE.DirectionalLight( 0xffffff);
                objectLight.position = camera.position;
                objectScene.add( objectLight );
				
                var interfaceLight = new THREE.DirectionalLight( 0xffffff);
                interfaceLight.position = camera.position;
                interfaceScene.add( interfaceLight );
				
                // GROUND
                groundGrid = new OSMEX.Grid(60, 4);
                objectScene.add( groundGrid );
                   
                groundPlane = new THREE.Plane( new THREE.Vector3(0, 1, 0));
                objectScene.add(groundPlane);
                		
                sizerGizmo = new OSMEX.SizerGizmo();
                interfaceScene.add(sizerGizmo);
                
                rotationGizmo = new OSMEX.RotationGizmo();
                interfaceScene.add(rotationGizmo);
                
                movingGizmo = new OSMEX.MovingGizmo();
                interfaceScene.add(movingGizmo);
                
                boxBuilder = new OSMEX.BoxBuilder();
                objectScene.add(boxBuilder);
                
                actionPlane = new THREE.Plane();
						
                projector = new THREE.Projector();	

                // RENDERER
                renderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );
                renderer.setClearColor( objectScene.fog.color, 1 );
                renderer.autoClear = false;

                container.appendChild( renderer.domElement );
				
                document.addEventListener( 'mousemove', onDocumentMouseMove, false );
                document.addEventListener( 'mousedown', onDocumentMouseDown, false );
                document.addEventListener( 'mouseup', onDocumentMouseUp, false );
                window.addEventListener( 'resize', onWindowResize, false );
            }
          
          function changeCamera ()
                {
                   console.log()
                }
            
          function addBoundingBox ()
                {
                    if($("#BBox").prop("checked")){
                        for (var i = FIRST_PICKABLE_OBJ, l = objectScene.children.length; i < l; i++) 
                        if (objectScene.children[i].geometry != null && objectScene.children[i].children[0] == undefined)
                            objectScene.children[i].add(new OSMEX.BoundingBox(objectScene.children[i]));

                    }
                    else{
                        for (var i = FIRST_PICKABLE_OBJ, l = objectScene.children.length; i < l; i++) 
                        if (objectScene.children[i].geometry != null && objectScene.children[i].children[0] != undefined)
                            objectScene.children[i].remove(objectScene.children[i].children[0]);

                    }           
                }
            
          function setArrowsType(element)
		{
                    //alert($(element).attr('id'));
                     arrowMode = $(element).attr('id');
		}
            function addObject(element)
		{
                    //alert($(element).attr('id'));
                    if($(element).attr('id') != "noarrows"){
                    BUILDING = new OSMEX.SketchBuilder($(element).attr('id'));
                    BUILDING.Sketch.pickable = false;
                    BUILDING.position.set(-1000,-1000,-1000);
                    objectScene.add (BUILDING);                    
                    }                       
		}
			
            function onWindowResize() {

                camera.setSize( window.innerWidth, window.innerHeight );
                camera.updateProjectionMatrix();

                renderer.setSize( window.innerWidth, window.innerHeight );
            }
            
            function getPickedObject() {
                
                function getFirstSuitableObject(raycaster, objects, recursive) {
                    
                    var intersects = raycaster.intersectObjects( objects, recursive );
                    
                    if ( intersects.length > 0 ) {

                        for( i = 0; i < intersects.length; i++ ) {
                            
                            if (intersects[i].object.parent.name === "RotationGizmoOverlay"){
                                if (i+1 < intersects.length && intersects[i+1].object.parent.name === "RotationTorus")
                                    i+=1;
                                else if (i+1 < intersects.length) continue;
                                                                                               
                                return null;                               
                            }
                        
                            var intersector = intersects[i];
                            
                            if ( intersector.object.pickable && intersector.object.visible ) {
 
                                return intersector.object;
                            }
                        }
                    }

                    return null;
                } 
                
                var vector = new THREE.Vector3( mouse.x, mouse.y, 1 );
                projector.unprojectVector( vector, camera );
				
                var raycaster = new THREE.Raycaster( camera.position, vector.sub( camera.position ).normalize() );
                
                var pickedObject = getFirstSuitableObject(raycaster, interfaceScene.children, true);
                
                if (pickedObject === null) {
                    
                    pickedObject = getFirstSuitableObject(raycaster, objectScene.children);                  
                }
                
                return pickedObject;
            }

            function onDocumentMouseMove( event ) {
                
                event.preventDefault();

                mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
                mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

                boxBuilder.onMouseMove(mouse);
                
                if ( BUILDING ) {       
                 
                    var vector = new THREE.Vector3( mouse.x, mouse.y, 0.5 );
	            projector.unprojectVector( vector, camera );
                    var ray = new THREE.Ray( camera.position, vector.sub( camera.position ).normalize() );
                    var intersectPoint = ray.intersectPlane(groundPlane);
                 
                    if ( intersectPoint !== undefined ) {
    
                        BUILDING.position.copy(intersectPoint);                    
                    }               
                }
                
                if ( DRAGGING ) {
                    
                    var vector = new THREE.Vector3( mouse.x, mouse.y, 0.5 );
	            projector.unprojectVector( vector, camera );
                    var ray = new THREE.Ray( camera.position, vector.sub( camera.position ).normalize() );
                    var intersectPoint = ray.intersectPlane(groundPlane);
                        
                    DRAGGING.position.copy(intersectPoint.sub( offsetVector ));
                }
                else if ( SIZING ) {
                    
                    var vector = new THREE.Vector3( mouse.x, mouse.y, 0.5 );
                    projector.unprojectVector( vector, camera );
                    var ray = new THREE.Ray( camera.position, vector.sub( camera.position ).normalize() );
                    var intersectPoint = ray.intersectPlane(actionPlane);

                    if (intersectPoint !== undefined) {
                        
                        intersectPoint.sub(new THREE.Vector3().getPositionFromMatrix(SIZING.matrixWorld));
                        intersectPoint.multiplyScalar(1.0 / SIZING.parent.scale.x); // to compensate changing scale on changing distance
                        SIZING.trackSizing(intersectPoint);
                    }
                }
                else if ( MOVING ) {
                    
                    var vector = new THREE.Vector3( mouse.x, mouse.y, 1 );
	            projector.unprojectVector( vector, camera );
                    var ray = new THREE.Ray( camera.position, vector.sub( camera.position ).normalize() );
                    var intersectPoint = ray.intersectPlane(actionPlane);
                 
                    if ( intersectPoint !== undefined ) {
                        
                        intersectPoint.sub( offsetVector );
                        MOVING.setPosition(intersectPoint);

                    }
                }
                else if ( SCALING ) {
                    
                    var mouseX = (mouse.x* SCREEN_WIDTH/2)/10;
                        
                    var sizingPos = projector.projectVector( new THREE.Vector3().getPositionFromMatrix(SCALING.matrixWorld).clone(), camera );
                    sizingPos.x = (sizingPos.x * SCREEN_WIDTH/2)/10;
                    var len = mouseX - sizingPos.x;

                    SCALING.setScale(len);     
                }
                else if ( ROTATING ) {
                    
                    var vector = new THREE.Vector3( mouse.x, mouse.y, 0.5 );
                    projector.unprojectVector( vector, camera );
                    var ray = new THREE.Ray( camera.position, vector.sub( camera.position ).normalize() );
                    var intersectPoint = ray.intersectPlane(actionPlane);

                    if (intersectPoint === undefined) {
                        alert("RotationEnd plane intersection problem!");
                    }

                    intersectPoint.sub( new THREE.Vector3().getPositionFromMatrix(ROTATING.matrixWorld));

                    ROTATING.finishRotation(intersectPoint.clone().normalize());   
                }
                else {
                    
                    var pickedObject = getPickedObject();

                    if ( PICKED != pickedObject ) {

                        if ( PICKED ) {
                            
                            if ( PICKED.material.emissive ) {
                                
                                PICKED.material.emissive.setHex( PICKED.oldEmissive );
                            }
                            else {
                                
                                PICKED.material.color.setHex( PICKED.oldColor );
                            }
                        }

                        PICKED = pickedObject;

                        if ( PICKED ) {
                            
                            if ( PICKED.material.emissive ) {
                                
                                PICKED.oldEmissive = PICKED.material.emissive.getHex();
                                PICKED.material.emissive.setHex( 0xff0000 );
                            }
                            else {
                            
                                PICKED.oldColor = PICKED.material.color.getHex();
                                PICKED.material.color.setHex( 0xffff00 );
                            }
                        }
                    }
                }
            }
			
            function onDocumentMouseDown( event ) {
                
                event.preventDefault();
				
                if (event.button == 0) {
                    
                    if (boxBuilder.isBuilding()) {
                        
                       boxBuilder.onLeftClick(mouse);
                       return;
                    }
                    
                    if (BUILDING){

                    var vector = new THREE.Vector3( mouse.x, mouse.y, 1 );
	            projector.unprojectVector( vector, camera );
                    var ray = new THREE.Ray( camera.position, vector.sub( camera.position ).normalize() );
                    var intersectPoint = ray.intersectPlane(groundPlane);
                 
                     var object = new OSMEX.SketchBuilder(BUILDING.name);
                     object.Sketch.position.copy(intersectPoint);
                     object.Sketch.material.color.setHex(0xffffff);  
                     
                     if (object.Sketch.children[0].name == "BoundingBox" && !$("#BBox").prop("checked"))
                         object.Sketch.remove(object.Sketch.children[0]);
                     
                     objectScene.add(object.Sketch);
                        
                    objectScene.remove(BUILDING);
                    
                    }
                                     
                    if ( PICKED ) {
                        
                        var pickRef = (PICKED.pickRef !== undefined ? PICKED.pickRef : PICKED);
                        cameraController.enabled = false;
                         
                        if (arrowMode == "delete") objectScene.remove(PICKED);
                        
                        if ( pickRef instanceof OSMEX.Block ) {

                            SELECTED = pickRef;
                            DRAGGING = pickRef;

                            var vector = new THREE.Vector3( mouse.x, mouse.y, 0.5 );
                            projector.unprojectVector( vector, camera );
                            var ray = new THREE.Ray( camera.position, vector.sub( camera.position ).normalize() );
                            var intersectPoint = ray.intersectPlane(groundPlane);                         
                            offsetVector.copy( intersectPoint ).sub( DRAGGING.position );
                        }
                        else if ( pickRef instanceof OSMEX.SizerArrow ) {

                            SIZING = pickRef;
                            
                            var rotatedDir = SIZING.dir.clone();
                            
                            SIZING.matrixRotationWorld.extractRotation( SIZING.matrixWorld );  
                            var rotatedDir = SIZING.dir.clone().applyMatrix4(SIZING.matrixRotationWorld).normalize();
                            var sizingPos = new THREE.Vector3().getPositionFromMatrix(SIZING.matrixWorld);
                            var cameraDir = camera.position.clone().sub(sizingPos).normalize();
                            var rightDir = cameraDir.clone().cross(rotatedDir).normalize();
                            var forwardDir = rotatedDir.clone().cross(rightDir).normalize();
                            actionPlane.setFromNormalAndCoplanarPoint(forwardDir, sizingPos);
                            // TODO: situation when user is doing camera rotation while LMK pressed should be considered!
                                      
                            sizerGizmo.setSizing(true);
                        }
                        else if ( pickRef instanceof OSMEX.MovingArrow || pickRef instanceof OSMEX.MovingGizmoPlane) {

                            MOVING = pickRef;
                            
                            if (pickRef instanceof OSMEX.MovingArrow) {

                                var sizingPos = new THREE.Vector3().getPositionFromMatrix(MOVING.matrixWorld);
                                var cameraDir = camera.position.clone().sub(sizingPos).normalize();
                                var rightDir = cameraDir.clone().cross(MOVING.dir); 
                                var forwardDir = MOVING.dir.clone().cross(rightDir);
                                actionPlane.setFromNormalAndCoplanarPoint(forwardDir, sizingPos);
                            }
                            else {
                                
                                var sizingPos = new THREE.Vector3().getPositionFromMatrix(MOVING.matrixWorld);
                                actionPlane.setFromNormalAndCoplanarPoint(MOVING.dir, sizingPos); 
                            }
                            
                            var vector = new THREE.Vector3( mouse.x, mouse.y, 0.5 );
                            projector.unprojectVector( vector, camera );
                            var ray = new THREE.Ray( camera.position, vector.sub( camera.position ).normalize() );
                            var intersectPoint = ray.intersectPlane(actionPlane);                         
                            offsetVector.copy( intersectPoint ).sub( new THREE.Vector3().getPositionFromMatrix(MOVING.matrixWorld) ); 
                        }
                        else if ( pickRef instanceof OSMEX.ScaleCube ) {
                            
                            SCALING = pickRef;
                                                       
                        }
                        else if ( pickRef instanceof OSMEX.RotationTorus ) {
                            
                            ROTATING = pickRef;
                            
                            ROTATING.matrixRotationWorld.extractRotation( ROTATING.matrixWorld );
                            var normal = ROTATING.dir.clone().applyMatrix4(ROTATING.matrixRotationWorld).normalize();
                            var rotationPos = new THREE.Vector3().getPositionFromMatrix(ROTATING.matrixWorld);
                            actionPlane.setFromNormalAndCoplanarPoint(normal, rotationPos);
                            // TODO: situation when user is doing camera rotation while LMK pressed should be considered!
                            
                            var vector = new THREE.Vector3( mouse.x, mouse.y, 0.5 );
                            projector.unprojectVector( vector, camera );
                            var ray = new THREE.Ray( camera.position, vector.sub( camera.position ).normalize() );
                            var intersectPoint = ray.intersectPlane(actionPlane);

                            if (intersectPoint === undefined) {
                                alert("RotationStart plane intersection problem!");
                            }
                            
                            intersectPoint.sub(new THREE.Vector3().getPositionFromMatrix(ROTATING.matrixWorld));

                            ROTATING.setStartRotationVector(intersectPoint.clone().normalize());
                           
                        }
                        else {
                            
                            SELECTED = null;
                        }
                    }
                    else {
                        
                        SELECTED = null;
                    }
                    if(arrowMode == "scaling") sizerGizmo.setTarget(SELECTED)
                        else if(arrowMode == "moving") movingGizmo.setTarget(SELECTED);
                            else if(arrowMode == "rotating") rotationGizmo.setTarget(SELECTED); 
                    
                    /*if(arrowMode == "moving") movingGizmo.setTarget(SELECTED) 
                    else {
                        rotationGizmo.setTarget(SELECTED);
                        sizerGizmo.setTarget(SELECTED);
                    }*/
                    
                }

            }
            
            function onDocumentMouseUp( event ) {
                
                event.preventDefault();
				
                if (event.button == 0) {
                   
                    cameraController.enabled = true;
                    
                    if (SIZING) {
                        
                        SIZING.restoreDefaultLength();
                        sizerGizmo.setSizing(false);
                    }
                    if (SCALING) SCALING.restoreDefaultScale();
                    
                    BUILDING = null;
                    DRAGGING = null;
                    SIZING = null;
                    SCALING = null;
                    ROTATING = null;
                    MOVING = null;
                }
            }

            function animate() {
                
                requestAnimationFrame( animate );
                
                update();
                render();
            }
            
            function update() {
                
                cameraController.update();
                rotationGizmo.update(camera);
                sizerGizmo.update();
                movingGizmo.update();
            } 
            
            function onCameraChange() {
                
                boxBuilder.update();
                render();
            } 
			
            function render() {
                
                renderer.clear();
                renderer.render( objectScene, camera );
                
                renderer.clear(false, true, false); // clear only Depth
                renderer.render( interfaceScene, camera );
            }
            
            
            $('#build_box').click(function() {
                
                boxBuilder.startBuild();
            });

        </script>

    </body>
</html>
